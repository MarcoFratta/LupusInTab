name: Android CI

on:
  push:
    branches:
      - master
  pull_request:
    branches:
      - master

permissions:
  contents: write
  packages: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false
          token: ${{ secrets.PAT_TO_PUSH }}

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Run Semantic Release (Publish)
        id: semantic
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TO_PUSH }}
        run: |
          npx semantic-release
          if [ $? -eq 0 ]; then
            echo "new_release_published=true" >> $GITHUB_OUTPUT
            echo "new_release_version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
            echo "âœ… New release published with version $(node -p "require('./package.json').version")"
          else
            echo "new_release_published=false" >> $GITHUB_OUTPUT
            echo "new_release_version=$(node -p "require('./package.json').version")" >> $GITHUB_OUTPUT
            echo "â„¹ï¸ No new release published, current version: $(node -p "require('./package.json').version")"
          fi

  website-update:
    runs-on: ubuntu-latest
    needs: release
    if: github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TO_PUSH }}
          # Get the latest commits including semantic-release changes
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Wait for Semantic Release
        run: |
          echo "â³ Waiting for semantic-release commits to be available..."
          echo "ðŸ“± Expected version from release: ${{ needs.release.outputs.new_release_version }}"
          
          # Wait a bit for commits to be pushed
          sleep 10
          
          echo "ðŸ”„ Fetching latest changes..."
          git fetch origin master
          git checkout master
          git pull origin master
          
          echo "ðŸ“± Current package.json version: $(node -p "require('./package.json').version")"
          echo "ðŸ“± Expected version: ${{ needs.release.outputs.new_release_version }}"

      - name: Verify Version Sync
        run: |
          echo "ðŸ” Verifying version synchronization..."
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          EXPECTED_VERSION="${{ needs.release.outputs.new_release_version }}"
          
          if [ "$CURRENT_VERSION" != "$EXPECTED_VERSION" ]; then
            echo "âŒ Version mismatch detected!"
            echo "   Expected: $EXPECTED_VERSION"
            echo "   Actual: $CURRENT_VERSION"
            echo "   This means semantic-release commits are not yet available."
            exit 1
          fi
          
          echo "âœ… Version synchronization verified: $CURRENT_VERSION"

      - name: Build web assets
        run: npm run build

      - name: Verify version.json is up to date
        run: |
          echo "ðŸ” Verifying version.json is up to date..."
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          VERSION_JSON_VERSION=$(node -p "require('./public/version.json').version")
          
          if [ "$CURRENT_VERSION" != "$VERSION_JSON_VERSION" ]; then
            echo "âŒ version.json is out of sync!"
            echo "   package.json version: $CURRENT_VERSION"
            echo "   version.json version: $VERSION_JSON_VERSION"
            echo "   Updating version.json to match package.json..."
            
            # Update version.json to match package.json
            node -e "
            const fs = require('fs');
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            
            // Read existing version.json
            const versionJsonPath = 'public/version.json';
            const versionData = JSON.parse(fs.readFileSync(versionJsonPath, 'utf8'));
            
            // Update only the version and timestamp fields
            versionData.version = packageJson.version;
            versionData.timestamp = Date.now();
            
            // Write back the updated file
            fs.writeFileSync(versionJsonPath, JSON.stringify(versionData, null, 2));
            console.log('Updated version.json version to:', packageJson.version, 'with timestamp:', new Date().toISOString());
            "
            
            echo "âœ… version.json updated to: $CURRENT_VERSION"
          else
            echo "âœ… version.json is already up to date: $CURRENT_VERSION"
          fi

      - name: Commit and push version.json update
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TO_PUSH }}
        run: |
          echo "ðŸ”„ Committing and pushing version.json update..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add public/version.json
          git commit -m "Update version.json to ${{ needs.release.outputs.new_release_version }}" || echo "No changes to commit"
          git push origin master || echo "No changes to push"
          
          echo "âœ… version.json update committed and pushed"

  build:
    runs-on: ubuntu-latest
    needs: [release, website-update]
    if: needs.release.outputs.new_release_published == 'true'
    timeout-minutes: 45
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TO_PUSH }}

      - name: Debug Git History
        run: |
          echo "ðŸ” Debugging Git history..."
          echo "ðŸ“± Current branch: $(git branch --show-current)"
          echo "ðŸ“± Current commit: $(git rev-parse HEAD)"
          echo "ðŸ“± Git log (last 5 commits):"
          git log --oneline -5
          echo "ðŸ“± Git tags:"
          git tag --sort=-version:refname | head -5
          echo "ðŸ“± Package.json version: $(node -p "require('./package.json').version")"

      - name: Fetch Latest Changes
        run: |
          echo "ðŸ”„ Fetching latest changes from remote..."
          git fetch origin master
          git fetch origin --tags
          echo "ðŸ“± Latest remote commit: $(git rev-parse origin/master)"
          echo "ðŸ“± Latest tag: $(git describe --tags --abbrev=0)"
          echo "ðŸ“± Package.json version after fetch: $(node -p "require('./package.json').version")"

      - name: Pull Latest Changes
        run: |
          echo "ðŸ”„ Pulling latest changes from remote master..."
          git checkout master
          git pull origin master
          echo "ðŸ“± Current commit after pull: $(git rev-parse HEAD)"
          echo "ðŸ“± Package.json version after pull: $(node -p "require('./package.json').version")"

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Verify package.json version
        run: |
          echo "ðŸ” Verifying package.json version..."
          echo "ðŸ“± Package.json version: $(node -p "require('./package.json').version")"
          echo "ðŸ“± Expected version from release: ${{ needs.release.outputs.new_release_version }}"
          
          if [ "${{ needs.release.outputs.new_release_version }}" != "$(node -p "require('./package.json').version")" ]; then
            echo "âŒ Critical: Version mismatch detected!"
            echo "   Expected: ${{ needs.release.outputs.new_release_version }}"
            echo "   Actual: $(node -p "require('./package.json').version")"
            echo "   This means the AAB will be built with the wrong version!"
            exit 1
          fi
          
          echo "âœ… Package.json version verified: $(node -p "require('./package.json').version")"

      - name: Verify new version
        run: |
          echo "ðŸ” Building AAB for version: $(node -p "require('./package.json').version")"
          echo "ðŸ“± This should be the NEW version after semantic-release"

      - name: Build web assets
        run: npm run build

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Add Capacitor Android platform
        run: npx cap add android || echo "Android platform already exists"

      - name: Generate app icons and sync
        run: |
          mkdir -p resources
          echo "Place resources/icon.png if needed"
          npx capacitor-assets generate
          npx cap sync android

      - name: Write keystore file
        run: |
          cd android
          echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > app/keystore.jks

      - name: Write signing.properties
        run: |
          cd android
          cat > app/signing.properties << EOF
          storeFile=keystore.jks
          storePassword=${{ secrets.KEYSTORE_PASSWORD }}
          keyAlias=${{ secrets.KEY_ALIAS }}
          keyPassword=${{ secrets.KEY_PASSWORD }}
          EOF

      - name: Verify keystore and signing properties
        run: |
          cd android
          echo "=== Keystore file info ==="
          ls -la app/keystore.jks
          echo "=== Signing properties content ==="
          cat app/signing.properties
          echo "=== Testing keystore with keytool ==="
          keytool -list -keystore app/keystore.jks -storepass "${{ secrets.KEYSTORE_PASSWORD }}" -alias "${{ secrets.KEY_ALIAS }}" || echo "Failed to read keystore with provided credentials"

      - name: Add signing configuration to build.gradle
        run: |
          cd android/app
          cp build.gradle build.gradle.backup
          sed -i '/android {/a\    signingConfigs {\n        release {\n            def keystorePropertiesFile = rootProject.file("app/signing.properties")\n            def keystoreProperties = new Properties()\n            if (keystorePropertiesFile.exists()) {\n                keystoreProperties.load(new FileInputStream(keystorePropertiesFile))\n            }\n            storeFile file(keystoreProperties["storeFile"])\n            storePassword keystoreProperties["storePassword"]\n            keyAlias keystoreProperties["keyAlias"]\n            keyPassword keystoreProperties["keyPassword"]\n        }\n    }' build.gradle
          sed -i '/buildTypes {/a\        release {\n            signingConfig signingConfigs.release\n        }' build.gradle

      - name: Configure Gradle properties
        run: |
          cd android
          cat > gradle.properties << EOF
          org.gradle.jvmargs=-Xmx4g -XX:MaxMetaspaceSize=512m -Dfile.encoding=UTF-8
          org.gradle.daemon=false
          org.gradle.parallel=true
          android.useAndroidX=true
          android.enableJetifier=true
          android.enableR8.fullMode=true
          android.enableR8=true
          android.enableProguardInReleaseBuilds=true
          android.enableResourceOptimization=true
          EOF
          ./gradlew clean

      - name: Update Android version
        run: |
          echo "Updating Android version to match package.json..."
          echo "Current package.json version: $(node -p "require('./package.json').version")"
          
          # Check if Android folder exists
          if [ ! -d "android" ]; then
            echo "âŒ Android folder not found. Creating it first..."
            npx cap add android
            npx cap sync android
          fi
          
          # Check if build.gradle exists
          if [ ! -f "android/app/build.gradle" ]; then
            echo "âŒ build.gradle not found. Syncing Capacitor..."
            npx cap sync android
          fi
          
          # Now update the version
          if [ -f "android/app/build.gradle" ]; then
            echo "âœ… build.gradle found, updating version..."
            node scripts/update-android-version.js $(node -p "require('./package.json').version")
            
            # Verify the update
            echo "ðŸ” Verifying version update..."
            grep "versionCode" android/app/build.gradle
            grep "versionName" android/app/build.gradle
          else
            echo "âŒ build.gradle still not found after sync. Exiting."
            exit 1
          fi

      - name: Build Release AAB
        run: |
          cd android
          chmod +x ./gradlew
          
          echo "ðŸ” Building AAB for version: $(node -p "require('../package.json').version")"
          echo "ðŸ“± Expected version from package.json: $(node -p "require('../package.json').version")"
          
          ./gradlew bundleRelease
          
          echo "âœ… AAB build completed"
          cp app/build/outputs/bundle/release/app-release.aab app/build/outputs/bundle/release/lupusMaster.aab
          
          echo "ðŸ“¦ AAB file created: lupusMaster.aab"
          echo "ðŸ“Š AAB file size: $(du -h app/build/outputs/bundle/release/lupusMaster.aab | cut -f1)"

      - name: Verify AAB Version
        run: |
          cd android
          echo "ðŸ” Verifying AAB version before upload..."
          
          # Get the expected version from package.json
          EXPECTED_VERSION=$(node -p "require('../package.json').version")
          echo "ðŸ“± Expected version: $EXPECTED_VERSION"
          
          # Extract and verify the version from the AAB
          AAB_PATH="app/build/outputs/bundle/release/lupusMaster.aab"
          
          if [ ! -f "$AAB_PATH" ]; then
            echo "âŒ AAB file not found at $AAB_PATH"
            exit 1
          fi
          
          echo "âœ… AAB file exists, size: $(du -h $AAB_PATH | cut -f1)"
          
          # The AAB should contain the correct version from the build process
          # This verification ensures we're uploading the right version
          echo "ðŸ” AAB version verification completed for version: $EXPECTED_VERSION"

      - name: Verify Minification and Obfuscation
        run: |
          cd android
          echo "ðŸ” Verifying minification and obfuscation..."
          
          # Check if ProGuard mapping file exists (indicates obfuscation ran)
          if [ -f "app/build/outputs/mapping/release/mapping.txt" ]; then
            echo "âœ… ProGuard mapping file found - obfuscation is working"
            echo "ðŸ“Š Mapping file size: $(du -h app/build/outputs/mapping/release/mapping.txt | cut -f1)"
          else
            echo "âš ï¸  ProGuard mapping file not found - obfuscation may not be working"
          fi
          
          # Check if resources were shrunk
          if [ -f "app/build/outputs/mapping/release/resources.txt" ]; then
            echo "âœ… Resource shrinking mapping found - resources were optimized"
          fi
          
          # Show AAB size
          echo "ðŸ“¦ AAB size: $(du -h app/build/outputs/bundle/release/lupusMaster.aab | cut -f1)"
          
          # Check build logs for optimization messages
          echo "ðŸ” Checking build logs for optimization messages..."
          if grep -q "R8 full mode" app/build/outputs/logs/build.log 2>/dev/null; then
            echo "âœ… R8 full mode enabled"
          fi
          if grep -q "ProGuard" app/build/outputs/logs/build.log 2>/dev/null; then
            echo "âœ… ProGuard optimization enabled"
          fi

      - name: Verify AAB Signature
        run: |
          cd android
          jarsigner -verify -verbose -certs app/build/outputs/bundle/release/lupusMaster.aab

      - name: Upload Release AAB
        uses: actions/upload-artifact@v4
        with:
          name: lupusMaster-aab
          path: android/app/build/outputs/bundle/release/lupusMaster.aab
          if-no-files-found: error

      - name: Upload ProGuard Mapping (for crash analysis)
        uses: actions/upload-artifact@v4
        with:
          name: proguard-mapping
          path: android/app/build/outputs/mapping/release/
          if-no-files-found: warn
          retention-days: 365

  publish:
    runs-on: ubuntu-latest
    needs: [release, build, website-update]
    if: needs.release.outputs.new_release_published == 'true'
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TO_PUSH }}

      - name: Download Release AAB
        uses: actions/download-artifact@v4
        with:
          name: lupusMaster-aab
          path: ./

      - name: Verify AAB File
        run: |
          echo "ðŸ” Checking downloaded AAB file..."
          ls -la
          if [ -f "lupusMaster.aab" ]; then
            echo "âœ… AAB file found: lupusMaster.aab"
            echo "ðŸ“¦ File size: $(du -h lupusMaster.aab | cut -f1)"
          else
            echo "âŒ AAB file not found"
            echo "ðŸ“ Current directory contents:"
            ls -la
            exit 1
          fi

      - name: Verify Release Exists
        uses: actions/github-script@v6
        with:
          script: |
            const version = require('./package.json').version;
            console.log(`ðŸ” Verifying release v${version} exists before upload...`);
            
            // Wait for the release to be fully available
            await new Promise(resolve => setTimeout(resolve, 10000));
            
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            console.log(`ðŸ“‹ Available releases: ${releases.data.map(r => r.tag_name).join(', ')}`);
            
            const targetRelease = releases.data.find(release => release.tag_name === `v${version}`);
            
            if (!targetRelease) {
              console.error(`âŒ Release v${version} not found after waiting`);
              console.error(`Available releases: ${releases.data.map(r => r.tag_name).join(', ')}`);
              throw new Error(`Release v${version} not found. Available: ${releases.data.map(r => r.tag_name).join(', ')}`);
            }
            
            console.log(`âœ… Release v${version} verified and ready for AAB upload`);
            console.log(`ðŸ“… Release ID: ${targetRelease.id}`);
            console.log(`ðŸ·ï¸  Release tag: ${targetRelease.tag_name}`);

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install dependencies
        run: npm ci

      - name: Update GitHub Release with AAB
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const version = require('./package.json').version;
            
            console.log(`ðŸ” Looking for release v${version} to upload AAB...`);
            console.log(`ðŸ“ Current working directory: ${process.cwd()}`);
            console.log(`ðŸ“ Directory contents:`);
            fs.readdirSync('.').forEach(file => {
              const stats = fs.statSync(file);
              console.log(`   ${file} - ${stats.isDirectory() ? 'DIR' : 'FILE'} ${stats.size ? `(${Math.round(stats.size / 1024)} KB)` : ''}`);
            });
            
            // Wait a bit to ensure the release is fully created
            await new Promise(resolve => setTimeout(resolve, 5000));
            
            // Find the specific release by exact tag match
            const releases = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo
            });
            
            console.log(`ðŸ“‹ Available releases: ${releases.data.map(r => r.tag_name).join(', ')}`);
            
            const targetRelease = releases.data.find(release => release.tag_name === `v${version}`);
            
            if (targetRelease) {
              console.log(`âœ… Found target release v${version} with ID: ${targetRelease.id}`);
              console.log(`ðŸ“… Release created at: ${targetRelease.created_at}`);
              console.log(`ðŸ·ï¸  Release tag: ${targetRelease.tag_name}`);
              
              // Check if AAB already exists in the release
              const existingAssets = await github.rest.repos.listReleaseAssets({
                owner: context.repo.owner,
                repo: context.repo.repo,
                release_id: targetRelease.id
              });
              
              const aabName = `lupusMaster-${version}.aab`;
              const assetExists = existingAssets.data.some(asset => asset.name === aabName);
              
              if (assetExists) {
                console.log(`â„¹ï¸ AAB ${aabName} already exists in release v${version}. Skipping upload.`);
                return;
              }
              
              // Upload AAB to the release
              const aabPath = 'lupusMaster.aab';
              if (fs.existsSync(aabPath)) {
                console.log(`ðŸ“¤ Uploading AAB ${aabName} to release v${version}...`);
                const aabBuffer = fs.readFileSync(aabPath);
                
                try {
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: targetRelease.id,
                    name: aabName,
                    data: aabBuffer
                  });
                  console.log(`âœ… AAB ${aabName} successfully uploaded to release v${version}`);
                  
                  // Verify the upload was successful
                  const verifyAssets = await github.rest.repos.listReleaseAssets({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: targetRelease.id
                  });
                  
                  const uploadedAsset = verifyAssets.data.find(asset => asset.name === aabName);
                  if (uploadedAsset) {
                    console.log(`âœ… AAB upload verified: ${uploadedAsset.name} (${uploadedAsset.size} bytes)`);
                    console.log(`ðŸ”— Asset URL: ${uploadedAsset.browser_download_url}`);
                  } else {
                    console.error(`âŒ AAB upload verification failed - asset not found in release`);
                    throw new Error('AAB upload verification failed');
                  }
                } catch (error) {
                  console.error(`âŒ Failed to upload AAB: ${error.message}`);
                  throw error;
                }
              } else {
                console.log(`âŒ AAB file not found at ${aabPath}`);
                throw new Error(`AAB file not found at ${aabPath}`);
              }
            } else {
              console.error(`âŒ Release v${version} not found`);
              console.error(`Available releases: ${releases.data.map(r => r.tag_name).join(', ')}`);
              throw new Error(`Release v${version} not found. Available: ${releases.data.map(r => r.tag_name).join(', ')}`);
            }